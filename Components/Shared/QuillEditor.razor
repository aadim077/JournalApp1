@inject IJSRuntime JSRuntime
@implements IDisposable

<div @ref="_editorContainer" class="quill-editor">
    <div @ref="_toolbarContainer">
        <!-- Toolbar items... -->
        <span class="ql-formats">
            <select class="ql-header">
                <option value="1"></option>
                <option value="2"></option>
                <option selected></option>
            </select>
        </span>
        <span class="ql-formats">
            <button class="ql-bold"></button>
            <button class="ql-italic"></button>
            <button class="ql-underline"></button>
            <button class="ql-strike"></button>
        </span>
        <span class="ql-formats">
            <button class="ql-list" value="ordered"></button>
            <button class="ql-list" value="bullet"></button>
        </span>
        <span class="ql-formats">
            <button class="ql-clean"></button>
        </span>
    </div>
    <div @ref="_editorElement" style="height: 300px;"></div>
</div>

@code {
    private ElementReference _editorContainer;
    private ElementReference _toolbarContainer;
    private ElementReference _editorElement;
    private DotNetObjectReference<QuillEditor>? _dotNetHelper;

    [Parameter] public string? Content { get; set; }
    [Parameter] public EventCallback<string> ContentChanged { get; set; }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync(
                "quillInterop.initialize", _editorElement, _toolbarContainer, Content, _dotNetHelper);
        }
    }

    [JSInvokable]
    public async Task OnContentChanged(string html)
    {
        if (Content != html)
        {
            Content = html;
            await ContentChanged.InvokeAsync(html);
        }
    }

    public void Dispose()
    {
        _dotNetHelper?.Dispose();
    }
}
